<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>JSDoc: Source: sdk.js</title>

    <script src="scripts/prettify/prettify.js"> </script>
    <script src="scripts/prettify/lang-css.js"> </script>
    <!--[if lt IE 9]>
      <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    <link type="text/css" rel="stylesheet" href="styles/prettify-tomorrow.css">
    <link type="text/css" rel="stylesheet" href="styles/jsdoc-default.css">
</head>

<body>

<div id="main">

    <h1 class="page-title">Source: sdk.js</h1>

    



    
    <section>
        <article>
            <pre class="prettyprint source linenums"><code>/*
 * Conversation SDK
 *  Main wrapper
 *
 * Copyright (c) Nexmo Inc. 2016
 */

var WildEmitter = require('wildemitter');
var socket_io = require('socket.io-client');
// logger = require('loglevel'),
var utils = require('./utils');
// RTC_Stats = require('./stats'),
var RTC_Cache = require('./cache');
var Application = require('./application').Application,
	User = require('./user').User;
var logger = require('loglevel-message-prefix')(require('loglevel'), {
	prefixes: ['level'],
	// staticPrefixes: ['Nexmo-SDK'],
	separator: '|'
});

// Conversation Client Error
var ConversationClientError = require('./conversationClientError');

var NexmoApiError = ConversationClientError.NexmoApiError;
// var NexmoClientError = ConversationClientError.NexmoClientError;

/**
 * The parent ConversationClient class.
 *
 * @class ConversationClient
 * @param {Object} params Configuration for the SDK. {debug:true}
 *
 * @fires ConversationClient#ready
 */
function ConversationClient(params) {
	//save an array of instances
	var self = this;
	var options = params || {};
	var config = this.config = {
		url: '@@ws_url',
		path: '/rtc',
		debug: false,
		reconnection: true,
		forceNew: true,
		autoConnect: true,
		ips_url: '@@ips_url',
		environment: '@@environment',
		SDK_version: '@@SDK_version',
		bugsnag_key: 'cd2dcd56892c3cd260b12caf6eecf022',
		repository: '@@repository'
	};
	var item,
		connection;
	this.requests = {};
	this.application = null;

	// set our config from options
	for (item in options) {
		this.config[item] = options[item];
	}

	//inject the reporting tool
	if (config.debug === true) {
		// logger.setLevel("trace");
		logger.setLevel("debug");
	} else {
		logger.setLevel("silent");
	}
	this.log = logger.noConflict();

	// this.stats = new RTC_Stats();
	this.cache = new RTC_Cache(this);

	//inject bug reporting tool
	function j(u, c) {
		var h = document.getElementsByTagName('head')[0],
			s = document.createElement('script');
		s.async = true;
		s.src = u;
		s.onload = s.onreadystatechange = function() {
			if (!s.readyState || /loaded|complete/.test(s.readyState)) {
				s.onload = s.onreadystatechange = null;
				s = undefined;
				if (c) {
					c();
				}
			}
		};
		h.insertBefore(s, h.firstChild);
	}
	if (typeof document !== "undefined") {
		j("//d2wy8f7a9ursnm.cloudfront.net/bugsnag-3.min.js", function() {
			if (typeof Bugsnag !== "undefined") {
				if (!Bugsnag.apiKey) {
					Bugsnag.apiKey = self.config.bugsnag_key;
					Bugsnag.releaseStage = self.config.environment;
					Bugsnag.appVersion = self.config.SDK_version;
					Bugsnag.repository = self.config.repository;
					Bugsnag.disableAutoBreadcrumbs();
				}
			}
		});
	}

	// call WildEmitter constructor
	WildEmitter.call(this);

	// Create the socket.io connection and allow multiple instances

	connection = socket_io.connect(config.url, {
		path: config.path,
		forceNew: config.forceNew,
		reconnection: config.reconnection,
		autoConnect: config.autoConnect

	});


	this.connection = connection;
	/**
	 * Ready event.
	 *
	 * @event ConversationClient#ready
	 * @example &lt;caption>Listen to websocket ready event &lt;/caption>
	 *     rtc.on("ready", function() {
	 *      console.log("connection ready");
	 *     });
	 */
	connection.on('connect', function() {
		self.emit('ready');
		self.sessionReady = true;
	});

	// Listen to socket.io events
	/**
	 * Connecting event.
	 *
	 * @event ConversationClient#connecting
	 * @example &lt;caption>Listen to websocket connecting event &lt;/caption>
	 *     rtc.on("connecting", function() {
	 *      console.log("connecting");
	 *     });
	 */
	connection.on('connecting', function() {
		self.emit('connecting');
	});
	/**
	 * Disconnect event.
	 *
	 * @event ConversationClient#disconnect
	 * @example &lt;caption>Listen to websocket disconnect event &lt;/caption>
	 *     rtc.on("disconnect", function() {
	 *      console.log("disconnect");
	 *     });
	 */
	connection.on('disconnect', function() {
		self.emit('disconnect');
	});
	/**
	 * Reconnect event.
	 *
	 * @event ConversationClient#reconnect
	 * @example &lt;caption>Listen to websocket reconnect event &lt;/caption>
	 *     rtc.on("reconnect", function(retry_number) {
	 *      console.log("reconnect", retry_number);
	 *     });
	 */
	connection.on('reconnect', function(retry_number) {
		self.emit('reconnect', retry_number);
		if (self.cache.user_data) {
			self.login(self.cache.user_data.token);
		}
	});
	/**
	 * Reconnecting event.
	 *
	 * @event ConversationClient#reconnecting
	 * @example &lt;caption>Listen to websocket reconnecting event &lt;/caption>
	 *     rtc.on("reconnecting", function(retry_number) {
	 *      console.log("reconnecting", retry_number);
	 *     });
	 */
	connection.on('reconnecting', function(retry_number) {
		self.emit('reconnecting', retry_number);
	});
	/**x
	 * Error event.
	 *
	 * @event ConversationClient#error
	 * @example &lt;caption>Listen to websocket error event &lt;/caption>
	 *     rtc.on("error", function(error) {
	 *      console.log("error", error);
	 *     });
	 */
	connection.on('error', function(error) {
		self.log.error("Socket.io reported a generic error", error);
	});

	connection.io.on('packet', function(packet) {
		if (packet.type !== 2) return;
		if (packet.data[0] === 'echo') return; //ignore echo events
		var response = packet.data[1];
		response.type = packet.data[0];
		//for stats
		// if (response.timestamp) {
		// 	response.delay = new Date() - new Date(response.timestamp);
		// }
		self.log.debug("&lt;--", response.type, JSON.stringify(response));
		// var own = false; //TODO Fix this to fix statistics for seperating properly own and other's messages
		// Set the type of the response
		if (response.rid in self.requests) {
			//check if we injected the cid (e.g. conversation:events, and cache it as well)
			if (self.requests[response.rid].cid) {
				response.cid = self.requests[response.rid].cid;
			}
			//use the cache object to determine if it's intended to be cachached and cache it
			self.cache.add_response(response);

			var callback = self.requests[response.rid].callback;
			delete self.requests[response.rid];
			delete response.delay;
			callback(response);
			// own = true;
		} else {
			// This is an unsolicited event
			//we are loosing here global application events.
			//TODO manage to pass on the member:invited when an invitation occures from user B to user C

			if (self.application)
				self.application._handleEvent(response);
		}
		//keep requests count for stats
		// if (self.stats) {
		// 	if (!(response.type in self.stats.runtime.request_types)) {
		// 		if (own) {
		// 			self.stats.runtime.request_types[response.type] = {
		// 				out: 1,
		// 				in: 0,
		// 				delay: response.delay ? response.delay : 0
		// 			};
		// 		} else {
		// 			self.stats.runtime.request_types[response.type] = {
		// 				out: 0,
		// 				in: 1,
		// 				delay: response.delay ? response.delay : 0
		// 			};
		// 		}
		// 	} else {
		// 		if (own) {
		// 			self.stats.runtime.request_types[response.type].in++;
		// 			if (response.delay)
		// 				self.stats.runtime.request_types[response.type].delay = response.delay;
		// 		} else {
		// 			self.stats.runtime.request_types[response.type].out++;
		// 			if (response.delay)
		// 				self.stats.runtime.request_types[response.type].delay = response.delay;
		// 		}
		// 	}
		// 	self.stats.runtime.pending_requests = Object.keys(self.requests).length;
		// }


	});
}

ConversationClient.prototype = new WildEmitter();

/**
 * Use notifications when the browser window is not visible to the user.
 *
 * @param {Object} params
 * @param {String} params.state - on || off to enable or disable the notifications
 * @param {String} params.dir=auto - auto|| ltr || rtl
 * @param {String} params.lang=EN - lang used within the notification.
 * @param {String} params.tag - An element ID to get/set the content
 * @param {String} params.icon - URL
 */

ConversationClient.prototype.notifications = function(params) {
	utils.setNotifications(params);
};

ConversationClient.prototype.isVisible = function() {
	return !utils.pageHidden;
};

ConversationClient.prototype.getVisibilityChangeEvent = function() {
	return utils.visibilityChangeEvent;
};

/**
 * Set the notification context
 *
 * @param {String} title the title of the notification
 * @param {String} text  the text message to display in the notification
 */
ConversationClient.prototype.notify = function(title, text) {
	utils.notify(title, text);
};
/**
 * Conversation listening for text events.
 *
 * @event Conversation#text
 *
 * @property {Member} sender - The sender of the text
 * @property {Text} text - The text message received
 * @example &lt;caption>listen for text events&lt;/caption>
 * conversation.on("text",
 *   function(sender, message) {
 *      console.log(sender,message);
 *
 * // Identify your own message.
 *      if (message.from !== conversation.me.id)
 *
 * // Identify if the event corresponds to the currently open conversation.
 *      if (message.cid === conversation.id)
 * });
 */
/**
 * @ignore
 *  Conversation listening for image events.
 *
 * @event Conversation#image
 *
 * @property {Member} sender - The sender of the image
 * @property {ImageEvent} image - The image message received
 * @example &lt;caption>listen for image events&lt;/caption>
 * conversation.on("image",
 *   function(sender, image) {
 *      console.log(sender,image);
 *
 * // Identify your own imageEvent.
 *      if (image.from !== conversation.me.id)
 *
 *  // Identify if the event corresponds to the currently open conversation.
 *      if (image.cid === conversation.id)
 * });
 */
/**
 * Conversation listening for deleted events.
 *
 * @event Conversation#event:delete
 *
 * @property {object} empty - empty object
 * @property {object} data - deleted event: data.event_id
 * @example &lt;caption>get the id of the deleted event&lt;/caption>
 * conversation.on("event:delete",
 *   function(empty, data) {
 *      console.log(data.event_id);
 * });
 */
/**
 * Conversation listening for new members.
 *
 * @event Conversation#member:joined
 *
 * @property {object} data -
 * @property {object} info - info about the member that joined the conversation
 * @example &lt;caption>get the name of the new member&lt;/caption>
 * conversation.on("member:joined",
 *   function(data, info) {
 *      console.log(info.user.name+ " joined the conversation");
 * });
 */
/**
 * Conversation listening for members being invited.
 *
 * @event Conversation#member:invited
 *
 * @property {object} data -
 * @property {object} receiver - data regarding the receiver of the invitation
 * @example &lt;caption>get the name of the invited member&lt;/caption>
 * conversation.on("member:invited",
 *   function(data, receiver ) {
 *      console.log(receiver.user.user_name + " invited to the conversation");
 * });
 */
/**
 * Conversation listening for members leaving (kicked or left).
 *
 * @event Conversation#member:left
 *
 * @property {object} data -
 * @property {object} member - information about the member that left
 * @example &lt;caption>get the username of the member that left&lt;/caption>
 * conversation.on("member:left",
 *   function(data , info ) {
 *      console.log(info.user.name + " left");
 * });
 */
/**
 * Conversation listening for members typing.
 *
 * @event Conversation#text:typing:on
 *
 * @property {object} data - info about the member that is typing
 * @example &lt;caption>get the username of the member that is typing&lt;/caption>
 * conversation.on("text:typing:on",
 *   function(data) {
 *      console.log(data.name + " is typing...");
 * });
 */
/**
 * Conversation listening for members stoped typing.
 *
 * @event Conversation#text:typing:off
 *
 * @property {object} data - info about the member that stopped typing
 * @example &lt;caption>get the username of the member that stopped typing&lt;/caption>
 * conversation.on("text:typing:off",
 *   function(data) {
 *      console.log(data.name + " stopped typing...");
 * });
 */
/**
 * Conversation listening for members' seen texts.
 *
 * @event Conversation#text:seen
 *
 * @property {object} data -
 * @property {Text} text - the text that was seen
 * @example &lt;caption>listen for seen text events&lt;/caption>
 * conversation.on("text:seen",
 *   function(data, text) {
 *      console.log(text);
 *
 * // Check if the event belongs to this conversation
 *      if (text.cid === conversation.id)
 *
 * // Get the list of members that have seen this event
 *      for (var member_id in text.state.seen_by) {
 *          if (conversation.me.id !== member_id) {
 *              console.log(conversation.members[member_id].name);
 *          }
 *       }
 * });
 */
/**
 * @ignore
 * Conversation listening for members' seen images.
 * @event Conversation#image:seen
 *
 * @property {object} data -
 * @property {ImageEvent} image - the image that was seen
 * @example &lt;caption>listen for seen image events&lt;/caption>
 * conversation.on("image:seen",
 *   function(data, image) {
 *      console.log(image);
 *
 * // Check if the event belongs to this conversation
 *      if (image.cid === conversation.id)
 * // Get the list of members that have seen this event
 *      for (var member_id in image.state.seen_by) {
 *           if (conversation.me.id !== member_id) {
 *               console.log(conversation.members[member_id].name);
 *            }
 *       }
 * });
 */
/**
 * Application listening for members media changes (audio, video,text)
 *
 * Change in media presence state. They are in the conversation with text, audio or video.
 * 
 * @event Application#member:media
 *
 * @property {object} data 
 * @property {object} media - information about media presence state
 * @property {boolean} media.audio  - is audio enabled
 * @property {boolean} media.video  - is video enabled
 * @property {boolean} media.text  - is text enabled
 * 
 * @todo how to get meber_id of the member who generate the event?
 * 
 * @example &lt;caption>get every member's media change events &lt;/caption>
 * conversation.on("member:media",
 *   function(data, media ) {
 *      console.log(media.audio);
 * });
 */
ConversationClient.prototype.sendRequest = function(request, callback) {
	// Add a message ID to the request and set up a listener for the reply (or error)
	var self = this;
	request.tid = utils.allocateUUID();
	var type = request.type;
	delete request.type;
	if (!self.cache) {
		return;
	}
	self.cache.process_cache(type, request, callback, self).then(function(processed_response) {
		if (processed_response) {
			callback(processed_response);
		} else {
			self.log.debug("-->", type, JSON.stringify(request));
			self.connection.emit(type, request);
			self.requests[request.tid] = {
				type: type,
				request: request,
				callback: callback
			};
			//make sure we keep the conversation each request belongs to
			//to keep aligned the cache
			if (request.cid)
				self.requests[request.tid].cid = request.cid;
			//for stats
			self.requests[request.tid].timestamp = new Date();
		}
	});
};

/**
 * Login to the cloud.
 *x
 * @param {String} params.token - the login token
 */
ConversationClient.prototype.login = function(token) {
	var self = this;

	// return a promise for the application
	var p = new Promise(function(resolve, reject) {
		//make sure the token gets removed from localstorage until we work the retry mechanism
		if (typeof(Storage) !== "undefined") {
			localStorage.removeItem("NXMO_user_data");
		}
		self.sendRequest({
				type: 'session:login',
				body: {
					token: token,
					SDK_version: self.config.SDK_version,
					//device_id: //can use https://github.com/Valve/fingerprintjs2,
					OS_family: 'js',
					OS_revision: (typeof navigator !== "undefined") ? navigator.userAgent : (typeof window !== "undefined") ? window.navigator.userAgent : "Generic JS navigator"
				}
			},

			function(response) {
				if (response.type === "session:success") {
					var application = new Application(self);
					var me = new User(application, {
						id: response.body.user_id,
						name: response.body.name
					});
					self.application = application;
					self.application.me = me;
					self.cache.updateToken({
						token: token,
						username: response.body.name
					});
					// Retrieve the existing conversation data for this user
					application.getConversations()
						.then(function() {
							// Complete the login process
							resolve(self.application);
							if (typeof Bugsnag !== "undefined") {

								Bugsnag.user = {
									id: application.me.id
								};
							}
						}, function(reason) {
							reject(new NexmoApiError(reason));
						});
				} else {
					reject(new NexmoApiError(response));
					if (self.cache &amp;&amp; self.cache.worker) {
						self.cache.worker.terminate();
					}
				}
			}
		);

	});
	return p;
};

/**
 * logout from the cloud.
 *
 */

ConversationClient.prototype.logout = function() {
	var self = this;
	// return a promise for the application
	var p = new Promise(function(resolve, reject) {
		self.sendRequest({
			type: 'session:logout',
			body: {}
		}, function(response) {
			if (response.type === "session:logged-out" || response.type === "session:terminated") {
				self.disconnect();
				self.cache.invalidate();

				if (self.application) {
					for (var conversation_id in self.application.conversations) {
						//unregister all events
						self.application.conversations[conversation_id].releaseGroup(conversation_id);
					}
				}
				delete self.app;
				delete self.cache;
				self.callbacks = {};
				//self.connection is safe to stay
				//self.log is safe to stay
				self.requests = {};
				delete self.sessionReady;
				// self.stats = new RTC_Stats();

				resolve(response);
			} else {
				// Previous state reject(response.reason); -- Untested
				reject(new NexmoApiError(response));
				if (typeof Bugsnag !== "undefined") Bugsnag.notifyException(Error(response.reason));
			}
		});
	});
	return p;
};

/**
 * Disconnect from the cloud.
 *
 */

ConversationClient.prototype.disconnect = function() {
	this.connection.disconnect();
};
/**
 * Connect from the cloud.
 *
 */
ConversationClient.prototype.connect = function() {
	this.connection.connect();
};

ConversationClient.prototype.callManager = new CallManager();

module.exports = ConversationClient;</code></pre>
        </article>
    </section>




</div>

<nav>
    <h2><a href="index.html">Home</a></h2><h3>Classes</h3><ul><li><a href="Application.html">Application</a></li><li><a href="CallManager.html">CallManager</a></li><li><a href="Conversation.html">Conversation</a></li><li><a href="ConversationClient.html">ConversationClient</a></li><li><a href="Event.html">Event</a></li><li><a href="Member.html">Member</a></li><li><a href="Text.html">Text</a></li></ul><h3>Events</h3><ul><li><a href="Application.html#event:member:invited">member:invited</a></li><li><a href="Application.html#event:member:joined">member:joined</a></li><li><a href="Application.html#event:member:media">member:media</a></li><li><a href="Conversation.html#event:event:delete">delete</a></li><li><a href="Conversation.html#event:text">text</a></li><li><a href="Conversation.html#event:member:invited">member:invited</a></li><li><a href="Conversation.html#event:member:joined">member:joined</a></li><li><a href="Conversation.html#event:member:left">member:left</a></li><li><a href="Conversation.html#event:text:seen">text:seen</a></li><li><a href="Conversation.html#event:text:typing:off">text:typing:off</a></li><li><a href="Conversation.html#event:text:typing:on">text:typing:on</a></li><li><a href="ConversationClient.html#event:connecting">connecting</a></li><li><a href="ConversationClient.html#event:disconnect">disconnect</a></li><li><a href="ConversationClient.html#event:error">error</a></li><li><a href="ConversationClient.html#event:ready">ready</a></li><li><a href="ConversationClient.html#event:reconnect">reconnect</a></li><li><a href="ConversationClient.html#event:reconnecting">reconnecting</a></li></ul><h3>Global</h3><ul><li><a href="global.html#ConversationClientErrorTypes">ConversationClientErrorTypes</a></li><li><a href="global.html#me">me</a></li><li><a href="global.html#NexmoApiError">NexmoApiError</a></li><li><a href="global.html#NexmoClientError">NexmoClientError</a></li><li><a href="global.html#NexmoClientErrorTypes">NexmoClientErrorTypes</a></li></ul>
</nav>

<br class="clear">

<footer>
    Documentation generated by <a href="https://github.com/jsdoc3/jsdoc">JSDoc 3.4.3</a> on Thu Oct 05 2017 15:28:56 GMT+0100 (BST)
</footer>

<script> prettyPrint(); </script>
<script src="scripts/linenumber.js"> </script>
</body>
</html>
