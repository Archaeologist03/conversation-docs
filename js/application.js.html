<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>JSDoc: Source: application.js</title>

    <script src="scripts/prettify/prettify.js"> </script>
    <script src="scripts/prettify/lang-css.js"> </script>
    <!--[if lt IE 9]>
      <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    <link type="text/css" rel="stylesheet" href="styles/prettify-tomorrow.css">
    <link type="text/css" rel="stylesheet" href="styles/jsdoc-default.css">
</head>

<body>

<div id="main">

    <h1 class="page-title">Source: application.js</h1>

    



    
    <section>
        <article>
            <pre class="prettyprint source linenums"><code>/*
 * Conversation SDK
 *  Application object model
 *
 * Copyright (c) Nexmo Inc. 2015
 */

var WildEmitter = require('wildemitter');
var User = require('./user').User;
var Conversation = require('./conversation').Conversation;

// Conversation Client Error
var ConversationClientError = require('./conversationClientError');

var NexmoApiError = ConversationClientError.NexmoApiError;
// var NexmoClientError = ConversationClientError.NexmoClientError;

/**
 * Core application class for the SDK.
 * Application is the parent object holding the list of conversations, the session object.
 * Provides methods to create conversations and retrieve a list of the user's conversations, while it holds the listeners for 
 * user's invitations 
 * @class
 * @param {ConversationClient} SDK session object
 * @param {Object} params
 * @example &lt;caption>Accessing conversations' list&lt;/caption>
 * 
 * rtc.login(token).then(
 *  function(application){
 * //get a list of conversations the logged in user has been invited to or has joined
 *      console.log(application.conversations);
 * //get the user's name and id
 *      console.lof(application.me.name, application.me.id)
 *   });
 */
var Application = function(session, params) {
	this.session = session;
	this.conversations = {};
	this.me = null;
	// Map the params
	for (var key in params) {
		this[key] = params[key];
	}
};

Application.prototype = new WildEmitter();

/**
 * Application listening for invites.
 *
 * @event Application#member:invited
 * 
 * @property {object} data - 
 * @property {object} invitation - The invitation
 * 
 * @example &lt;caption>listen for your invites&lt;/caption>
 * application.on("member:invited",
 *   function(data, invitation) {
 *      console.log(data, invitation);    
 * 
 * //identify the sender.
 * console.log("received from: " + invitation.body.invited_by);
 * 
 * //get the conversation id and name to use to accept/decline the invitation.
 * console.log(invitation.cid);
 * console.log(invitation.body.cname);
 * 
 * //accept an invitation.
 *  application.getConversation(invitation.cid || invitation.body.cname)
 *      .then(function(conversation_to_join) {
 *          conversation_to_join.join();
 *       });
 * });
 * 
 * //decline the invitation. //to be simplified
 * application.getConversation(invitation.cid || invitation.body.cname)
 *      .then(function(conversation_to_dismiss){
 *         conversation_to_dismiss.members[invitation.body.user.member_id].kick(); 
 *      });
 */
/**
 * Application listening for joins.
 *
 * @event Application#member:joined
 * 
 * @property {object} member_id - the id of the member that performed the action
 * @property {object} data -  information about the conversation
 * 
 * @example &lt;caption>listen join events&lt;/caption>
 *  application.on("member:joined",
 *      function(sender_member_id, data) {
 *              console.log("JOINED", "Joined conversation: " + data.cid);
 *              });
 *      });
 */
/**
 * @ignore
 * Application listening for audio call invitations.
 *
 * @event Application#member:invited:audio
 * 
 * @property {object} data - 
 * @property {object} invitation - The invitation
 * 
 * @example &lt;caption>listen for your calls&lt;/caption>
 * application.on("member:invited:audio",
 *   function(data, invitation) {
 *      console.log(data, invitation);
 * 
 * //accept or decline calls by joining or leaving the invitation as above (to be simplified)
 */
Application.prototype._handleEvent = function(event) {
	var self = this;
	switch (event.type) {
		case "member:invited":
			//detect audio type invitation
			if (event.body.user.media &amp;&amp; event.body.user.media.audio) {
				//if the invitation is for me append the audio type for audio
				if (self.me.id === event.body.user.user_id) {
					event.type = "member:invited:audio";
					self.emit(event.type, event.from, event);
					break;
				}
			}
			routeEvent();
			break;
		case "member:joined":
			//in case we don't know about the conversation, the event will be redirected to application level
			//the requests on that level need the cid to be processed. but in member:joined event that brings inconsistency
			var mutate_event;
			if (!self.conversations[event.cid]) {
				event.body.cid = event.cid;
				event.body.type = event.type;
				event.body.from = event.from;
				mutate_event = event.body;
			}
			routeEvent();
			break;
		default:
			routeEvent();
			break;
	}

	function routeEvent() {
		var cid = event.cid;
		if (cid in self.conversations) {
			self.conversations[cid]._handleEvent(event);
		} else {
			//get the conversation you don't know about (case: joined by another user)
			self.getConversation(cid).then(function(conversation) {
				self.conversations[cid] = conversation;
				self.emit(event.type, event.from, mutate_event || event);
			});
		}
	}
};

/**
 * Query the service to create a new conversation
 * The conversation name must be unique per application.
 * @param {Object} [params] - leave empty to get a GUID as name
 * @param {String} params.name - the name of the conversation. A UID will be assigned if this is skipped
 * @param {String} params.display_name - the display_name of the conversation.
 * @returns {Promise&lt;Conversation>} - the created Conversation
 * @example &lt;caption>Create a conversation and join&lt;/caption>
 * application.newConversation().then(
 *     function(conversation) {
 * 
 *         //join the created conversation
 *         conversation.join().then(
 *             //Get the user's memeber belonging in this conversation.
 *             //You can also access it via conversation.me
 *             function(member) {
 *                 console.log("Joined as " + member.name);
 *             });
 * 
 *     }).catch(function(error) {
 *     console.log(error);
 * });
 */
Application.prototype.newConversation = function(params) {
	var self = this;
	var p = new Promise(function(resolve, reject) {
		self.session.sendRequest({
			type: 'new:conversation',
			body: params
		}, function(response) {
			if (response.type === 'new:conversation:success') {
				var conv = new Conversation(self, response.body);
				self.conversations[conv.id] = conv;
				// do a get conversation to get the whole model as shaped in the service, 
				// it's not expensive here as it's empty of events
				self.getConversation(conv.id).then(function(conversation) {
					resolve(conversation);
				});
			} else {
				reject(new NexmoApiError(response));
			}
		});
	});
	return p;
};

/**
 * Query the service to create a new conversation and join it
 * The conversation name must be unique per application.
 * @param {Object} [params] - leave empty to get a GUID as name
 * @param {String} params.name - the name of the conversation. A UID will be assigned if this is skipped
 * @param {String} params.display_name - the display_name of the conversation.
 * @returns {Promise&lt;Conversation>} - the created Conversation
 * @example &lt;caption>Create a conversation and join&lt;/caption>
 * application.newConversationAndJoin().then(
 *     function(conversation) {
 * 
 *         //join the created conversation
 *         conversation.join().then(
 *             //Get the user's memeber belonging in this conversation.
 *             //You can also access it via conversation.me
 *             function(member) {
 *                 console.log("Joined as " + member.name);
 *             });
 * 
 *     }).catch(function(error) {
 *     console.log(error);
 * });
 */
Application.prototype.newConversationAndJoin = function(params) {
	var self = this;
	return self.newConversation(params).then(function(conversation) {
		return conversation.join().then(function() {
			return conversation;
		});
	});

};
/**
 * Query the service to obtain a complete list of conversations of which the
 * logged-in user is a member with a state of `JOINED` or `INVITED`. 
 * 
 * @returns {Promise&lt;Object&lt;Conversation>>} - Populate Application.conversations.
 */
Application.prototype.getConversations = function(params) {
	var self = this;
	var p = new Promise(function(resolve, reject) {
		self.session.sendRequest({
			type: 'user:conversations',
			body: params
		}, function(response) {
			if (response.type === 'user:conversations:success') {
				// Iterate and create the conversations if not existent
				// (note that cache WebWorker also populates conv list)
				// These are just templates without the full member information

				// TODO - need to get rid of references to deleted / left
				// conversations:
				response.body.map(function(c) {
					var conv = new Conversation(self, c);
					if (self.conversations[conv.id] === undefined) {
						self.conversations[conv.id] = conv;
					}
				});
				resolve(self.conversations);
			} else {
				reject(new NexmoApiError(response));
			}
		});
	});
	return p;
};

/**
 * Query the service to see if this conversation exists with the
 * logged in user as a member and retrieve the data object
 * Result added (or updated) in this.conversations
 * use force=true to skip cache
 * 
 * @param {String} id - the id of the conversation to fetch
 * @param {Boolean} [force=false] - set to true to skip cached data
 * 
 * @returns {Promise&lt;Conversation>} - the requested conversation 
 */
Application.prototype.getConversation = function(id, force) {
	var self = this;
	var p = new Promise(function(resolve, reject) {
		self.session.sendRequest({
			type: 'conversation:get',
			cid: id,
			body: {},
			force: force //temp flag to skip cache
		}, function(response) {
			if (response.type === 'conversation:get:success') {
				var updateOrCreateConversation = function() {
					if (self.conversations[response.body.id]) {
						self.conversations[response.body.id].updateObjectInstance(self, response.body);
						return self.conversations[response.body.id];
					}
					return new Conversation(self, response.body);
				};
				//check if the response is from cache already formed as Conversation object, reuse it
				var conv = (response.body instanceof Conversation) ?
					response.body : updateOrCreateConversation();


				self.conversations[conv.id] = conv;
				// Populate the events
				conv.getEvents().then(function(events) {
					// Complete
					conv.events = events;
					resolve(conv);
					//update cached conversation to maintain proper event objects
					self.session.cache.update_conversation(conv);

				});
			} else {
				reject(new NexmoApiError(response));
			}
		});
	});
	return p;
};

/**
 * Get Details of a user
 * @param {String} [id] - the id of the user to fetch, if skipped, it returns your own user details
 * @returns {Promise&lt;User>} 
 */
Application.prototype.getUser = function(user_id) {
	user_id = user_id || this.me.id;
	var self = this;
	var p = new Promise(function(resolve, reject) {
		var params = {
			user_id: user_id
		};
		self.session.sendRequest({
			type: 'user:get',
			from: self.me.id,
			body: params
		}, function(response) {
			if (response.type === 'user:get:success') {
				resolve(new User(self, response.body));
			} else {
				reject(new NexmoApiError(response));
			}
		});
	});
	return p;
};


module.exports = {
	Application: Application
};</code></pre>
        </article>
    </section>




</div>

<nav>
    <h2><a href="index.html">Home</a></h2><h3>Classes</h3><ul><li><a href="Application.html">Application</a></li><li><a href="Conversation.html">Conversation</a></li><li><a href="ConversationClient.html">ConversationClient</a></li><li><a href="Event.html">Event</a></li><li><a href="Member.html">Member</a></li><li><a href="Text.html">Text</a></li></ul><h3>Events</h3><ul><li><a href="Application.html#event:member:invited">member:invited</a></li><li><a href="Application.html#event:member:joined">member:joined</a></li><li><a href="Application.html#event:member:media">member:media</a></li><li><a href="Conversation.html#event:event:delete">delete</a></li><li><a href="Conversation.html#event:text">text</a></li><li><a href="Conversation.html#event:member:invited">member:invited</a></li><li><a href="Conversation.html#event:member:joined">member:joined</a></li><li><a href="Conversation.html#event:member:left">member:left</a></li><li><a href="Conversation.html#event:text:seen">text:seen</a></li><li><a href="Conversation.html#event:text:typing:off">text:typing:off</a></li><li><a href="Conversation.html#event:text:typing:on">text:typing:on</a></li><li><a href="ConversationClient.html#event:connecting">connecting</a></li><li><a href="ConversationClient.html#event:disconnect">disconnect</a></li><li><a href="ConversationClient.html#event:error">error</a></li><li><a href="ConversationClient.html#event:ready">ready</a></li><li><a href="ConversationClient.html#event:reconnect">reconnect</a></li><li><a href="ConversationClient.html#event:reconnecting">reconnecting</a></li></ul><h3>Global</h3><ul><li><a href="global.html#ConversationClientErrorTypes">ConversationClientErrorTypes</a></li><li><a href="global.html#me">me</a></li><li><a href="global.html#NexmoApiError">NexmoApiError</a></li><li><a href="global.html#NexmoClientError">NexmoClientError</a></li><li><a href="global.html#NexmoClientErrorTypes">NexmoClientErrorTypes</a></li></ul>
</nav>

<br class="clear">

<footer>
    Documentation generated by <a href="https://github.com/jsdoc3/jsdoc">JSDoc 3.4.3</a> on Thu Sep 21 2017 17:44:00 GMT+0100 (BST)
</footer>

<script> prettyPrint(); </script>
<script src="scripts/linenumber.js"> </script>
</body>
</html>
