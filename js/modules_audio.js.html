<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>JSDoc: Source: modules/audio.js</title>

    <script src="scripts/prettify/prettify.js"> </script>
    <script src="scripts/prettify/lang-css.js"> </script>
    <!--[if lt IE 9]>
      <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    <link type="text/css" rel="stylesheet" href="styles/prettify-tomorrow.css">
    <link type="text/css" rel="stylesheet" href="styles/jsdoc-default.css">
</head>

<body>

<div id="main">

    <h1 class="page-title">Source: modules/audio.js</h1>

    



    
    <section>
        <article>
            <pre class="prettyprint source linenums"><code>/*
 * Conversation SDK
 *  Conversation object model
 *
 * Copyright (c) Nexmo Inc. 2017
 */

var ConversationClientError = require('../conversationClientError');
var RtcHelper = require('./rtc_helper').RtcHelper;

var NexmoApiError = ConversationClientError.NexmoApiError;
var NexmoClientError = ConversationClientError.NexmoClientError;

var rtcHelper = new RtcHelper();

/**
 * WebRTC Audio class
 * @class Audio 
 * @ignore
 */

var Audio = function(conversation) {
	if (conversation) {
		this.parentConversation = conversation;
		this.application = conversation.application;
	}
}

/**
 * @ignore
 * Earmuff our member
 * 
 * @param {Boolean} [params] 
 * 
 * @returns {Promise} 
 */
Audio.prototype.earmuff = function(earmuff) {
	var self = this;
	var params = {};
	var p = new Promise(function(resolve, reject) {
		if (self.me === null) {
			reject(new NexmoClientError("error:self"));
		} else {
			var type = 'audio:earmuff:off';
			if (earmuff) {
				type = 'audio:earmuff:on';
			}
			self.application.session.sendRequest({
				type: type,
				cid: self.parentConversation.id,
				to: self.parentConversation.me.id,
				body: params
			}, function(response) {
				var onoff = (earmuff) ? 'on' : 'off';
				if (response.type === 'audio:earmuff:' + onoff + ':success') {
					resolve(response.body);
				} else {
					reject(new NexmoApiError(response));
				}
			});
		}
	});
	return p;
};


/**
 * Enable audio participation in the conversation for this application (requires WebRTC)
 * if AudioContext is supported the mediaStreamSource will be automatically connected
 * @param {Object} params - rtc params
 * @param {String} params.label - Label is an application defined tag, eg. ‘fullscreen’
 *
 * @returns {Promise&lt;MediaStream>}
 * @example
 * Enable audio in this conversation
 * function enable() {
 *   conversation.audio.enable()
 *      .then(function(stream) {
	 		var audio = document.createElement("audio");
			var source = document.createElement("source");
			var audio_div = document.createElement("div");

			audio.appendChild(source);
			audio_div.appendChild(audio);
			document.insertBefore(audio_div);
			
			// Older browsers may not have srcObject
			if ("srcObject" in audio) {
				audio.srcObject = stream;
			} else {
				// Avoid using this in new browsers, as it is going away.
				audio.src = window.URL.createObjectURL(stream);
			}
			
			audio.onloadedmetadata = function(e) {
				audio.play();
			};
	*      
 * 		 }).catch(function(error) {
 *           console.log(error);
 *       });
 * }
 * 
 * 
 * 
 **/
Audio.prototype.enable = function(params) {
	var self = this;
	var p = new Promise(function(resolve, reject) {
		function onError(error) {
			self.application.session.log.error(error);
			reject(new NexmoApiError(error));
		}
		if (self.parentConversation.me === null) {
			reject(new NexmoClientError('error:self'));
		} else {
			if (self.application.activeStream &amp;&amp; self.application.activeStream.stream) {
				reject(new NexmoClientError('error:audio:already-connecting'));
			}
			self.application.activeStream = {
				conversation: self.parentConversation
			};
			rtcHelper.getUserAudio().then(
				function(localStream) {
					/* jshint -W117 */
					var pc = new RTCPeerConnection({
						'iceServers': [self.application.session.config.iceServers],
						'iceTransportPolicy': 'all',
						'bundlePolicy': 'balanced',
						'rtcpMuxPolicy': 'require',
						'iceCandidatePoolSize': '0'
					}, {
						optional: [{
							'DtlsSrtpKeyAgreement': 'true'
						}]
					});
					self.parentConversation.pc = pc;
					self.parentConversation.localStream = localStream;
					pc.ontrack = function(evt) {
						self.application.activeStream.stream = evt.streams[0]
						resolve(evt.streams[0]);
					};
					pc.addStream(localStream);
					pc.createOffer(
						function(desc) {
							pc.setLocalDescription(desc, function() {}, onError);
						},
						onError);
					pc.oniceconnectionstatechange = function(status) {
						switch (pc.iceConnectionState) {
							//https://developer.mozilla.org/en-US/docs/Web/API/RTCPeerConnection/iceConnectionState
							case 'disconnected':
							case 'failed':
								onError(status);
								self.application.session.log.warn('One or more transports has terminated unexpectedly or in an error', status);
								break;
							default:
								self.application.session.log.debug('The ice connection status changed', pc.iceConnectionState);
								break;
						}
					}
					pc.onicegatheringstatechange = function() {
						switch (pc.iceGatheringState) {
							case 'new':
								self.application.session.log.debug('ice gathering new');
								break;
							case 'complete':
								self.application.session.log.debug('ice gathering complete');
								var event_to_emit = {
									type: 'rtc:new',
									cid: self.parentConversation.id,
									from: self.parentConversation.me.id,
									body: {
										offer: self.parentConversation.pc.localDescription
									}
								}
								if (params &amp;&amp; params.label) {
									event_to_emit.label = params.label;
								}
								self.application.session.sendRequest(event_to_emit,
									function(response) {
										if (response.type === 'rtc:new:success') {
											self.application.activeStream.rtc_id = response.body.rtc_id;
											//dont resolve yet, wait for the answer
											// resolve(response.type);
										} else {
											reject(new NexmoApiError(response));
										}
									});
								break;
							case 'gathering':
								self.application.session.log.debug('ice gathering gathering');
								break;
						}
					}
				}).then(function() {
				// We want to be able to handle these events, for self member, before they get propagated out
				self.parentConversation.on('rtc:answer', function(event) {
					if (self.application.activeStream.rtc_id !== event.body.rtc_id) {
						self.application.session.log.warn("RTC: skipping  rtc answer for different rtc_id");
					}
					self.parentConversation.pc.setRemoteDescription(new RTCSessionDescription({
							type: 'answer',
							sdp: event.body.answer
						}),
						function() {
							self.application.session.log.debug('remote description is set');
						},
						onError);
				});
				//on member delete (ourself)
				//terminate audio
				self.parentConversation.on('member:left', function(data, member) {
					if (member.user.id === self.application.me.id) {
						self.disable();
					}
				});
			}).catch(function(error) {
				reject(new NexmoClientError(error));
			});
		}
	});
	return p;
};

/**
 * Disable audio partcipation in the conversation for this application
 * 
 * @returns {Promise}
 * @example
 *
 * function disable() {
 *   conversation.audio.disable()
 *      .then(function(response) {
 *       }).catch(function(error) {
 *           console.log(error);
 *       });
 * }
 * 
 **/
Audio.prototype.disable = function() {
	var self = this;
	var p = new Promise(function(resolve, reject) {
		if (!self.application.activeStream) {
			reject(new NexmoClientError('error:audio:not-enabled'));
			return;
		}
		self.application.session.sendRequest({
			type: 'rtc:terminate',
			cid: self.parentConversation.id,
			from: self.parentConversation.me.id,
			rtc_id: self.application.activeStream.rtc_id
		}, function(response) {
			if (response.type === 'rtc:terminate:success') {
				resolve(response.type);
				if (self.application.localStream) {
					self.application.localStream.getTracks()[0].stop();
				}
				if (self.application.activeStream.stream) {
					self.application.activeStream.stream.getTracks()[0].stop();
				}
				self.parentConversation.pc.close();
				self.application.activeStream = {};
			} else {
				reject(new NexmoApiError(response));
			}
		});
	});
	return p;
};

/** 
 * Play a voice text in a conversation
 * @param {Object} params
 * @param {String} params.text - the text to say in the conversation
 * @param {String} params.voice_name -
 * @param {Number} params.level = [0] - 
 * @param {Boolean} params.queue - 
 * @param {Boolean} params.loop - 
 * 
 * @returns {Promise}
 * @example
 *   conversation.audio.say({text:'hi'})
 **/

//to stop 
//
//audio:say:stop
//body: {
//   say_id: &lt;say_id>
//}

/**
 * @ignore
 * Mute this member
 * 
 * @param {Boolean} [params] is muted
 * 
 * @returns {Promise} - 
 */
Audio.prototype.mute = function(mute) {
	var self = this;
	var params = {};
	var p = new Promise(function(resolve, reject) {
		var type = 'audio:mute:off';
		if (mute) {
			type = 'audio:mute:on';
		}
		self.application.session.sendRequest({
			type: type,
			cid: self.parentConversation.id,
			to: self.parentConversation.me.id,
			body: params
		}, function(response) {
			var onoff = (mute) ? 'on' : 'off';
			if (response.type === 'audio:mute:' + onoff + ':success') {
				resolve(response.body);
			} else {
				reject(new NexmoApiError(response));
			}
		});
	});
	return p;
};

Audio.prototype.sayText = function(params) {
	var self = this;
	var p = new Promise(function(resolve, reject) {
		var msg = {
			type: 'audio:say',
			cid: self.parentConversation.id,
			body: {
				text: params.text,
				voice_name: params.voice_name || 'Amy',
				level: params.level || 1,
				queue: params.queue || true,
				loop: params.loop || 1,
				ssml: params.ssml || false
			}
		};
		self.application.session.sendRequest(msg, function(response) {
			if (response.type === 'audio:say:success') {
				msg.id = response.body.id;
				var event = new Event(self.parentConversation, response);
				resolve(event);
			} else {
				reject(new NexmoApiError(response));
			}
		});
	});
	return p;
};

/**
 * Record the audio stream in a conversation
 * @param {Object} params
 * @param {String} params.format = (mp3, wav, ogg)
 * @param {Boolean} params.streamed - 
 * @param {Number} params.validity_time - 
 * @param {Boolean} params.beep_start - 
 * @param {Boolean} params.beep_stop -~
 * @param {Boolean} params.detect_speech -
 * 
 * @returns {Promise}
 * @example
 *   conversation.audio.record()
 */

// Record this conversation that the message is addressed to. 
// To stop the recording delete the message, 
// which will result in an event
Audio.prototype.record = function(params) {
	var self = this;
	var p = new Promise(function(resolve, reject) {
		var msg = {
			type: 'audio:record',
			cid: self.id,
			body: {
				format: params.format,
				destination_url: params.destination_url,
				streamed: params.streamed,
				validity_time: params.validity_time,
				beep_start: params.beep_start,
				beep_stop: params.beep_stop,
				detect_speech: params.detect_speech
			}
		};
		self.application.session.sendRequest(msg, function(response) {
			if (response.type === 'audio:record:success') {
				msg.id = response.body.id;
				var event = new Event(self.parentConversation, response);
				resolve(event);
			} else {
				reject(new NexmoApiError(response));
			}
		});
	});
	return p;
};


// Play a stream to the conversation
Audio.prototype.playStream = function(params) {
	var self = this;
	var p = new Promise(function(resolve, reject) {
		var msg = {
			type: 'audio:play',
			cid: self.parentConversation.id,
			body: params
		};
		self.application.session.sendRequest(msg, function(response) {
			if (response.type === 'audio:play:success') {
				msg.id = response.body.id;
				var event = new Event(self.parentConversation, response);
				resolve(event);
			} else {
				reject(new NexmoApiError(response));
			}
		});
	});
	return p;
};

/**
 * Send start ringing event
 * @returns {Promise}
 * @example
 * Send ringing event
 * function ringingStart() {
 *   conversation.audio.ringingStart()
 *      .then(function(response) {
 *       }).catch(function(error) {
 *           console.log(error);
 *       });
 * }
 * 
 * conversation.on('audio:ringing:start', function(data)){
 * console.log("ringing");
 * }
 */
Audio.prototype.ringingStart = function() {
	var self = this;
	var p = new Promise(function(resolve, reject) {
		var msg = {
			type: 'audio:ringing:start',
			cid: self.parentConversation.id,
			from: self.parentConversation.me.id,
			body: {}
		};
		self.application.session.sendRequest(msg, function(response) {
			if (response.type === 'audio:ringing:start:success') {
				msg.id = response.body.id;
				var event = new Event(self.parentConversation, response);
				resolve(event);
			} else {
				reject(new NexmoApiError(response));
			}
		});
	});
	return p;
};

/**
 * Send stop ringing event
 * @returns {Promise}
 * @example
 * Send ringing event
 * function ringingStop() {
 *   conversation.audio.ringingStop()
 *      .then(function(response) {
 *       }).catch(function(error) {
 *           console.log(error);
 *       });
 * }
 * 
 * conversation.on('audio:ringing:stop', function(data)){
 * console.log("ringing stopped");
 * }
 */
Audio.prototype.ringingStop = function() {
	var self = this;
	var p = new Promise(function(resolve, reject) {
		var msg = {
			type: 'audio:ringing:stop',
			cid: self.parentConversation.id,
			from: self.parentConversation.me.id,
			body: {}
		};
		self.application.session.sendRequest(msg, function(response) {
			if (response.type === 'audio:ringing:stop:success') {
				msg.id = response.body.id;
				var event = new Event(self.parentConversation, response);
				resolve(event);
			} else {
				reject(new NexmoApiError(response));
			}
		});
	});
	return p;
}

module.exports = {
	Audio: Audio
};</code></pre>
        </article>
    </section>




</div>

<nav>
    <h2><a href="index.html">Home</a></h2><h3>Classes</h3><ul><li><a href="Application.html">Application</a></li><li><a href="Conversation.html">Conversation</a></li><li><a href="ConversationClient.html">ConversationClient</a></li><li><a href="Event.html">Event</a></li><li><a href="ImageEvent.html">ImageEvent</a></li><li><a href="Member.html">Member</a></li><li><a href="TextEvent.html">TextEvent</a></li></ul><h3>Events</h3><ul><li><a href="Application.html#event:member:invited">member:invited</a></li><li><a href="Application.html#event:member:joined">member:joined</a></li><li><a href="Conversation.html#event:event:delete">delete</a></li><li><a href="Conversation.html#event:text">text</a></li><li><a href="Conversation.html#event:image:seen">image:seen</a></li><li><a href="Conversation.html#event:member:invited">member:invited</a></li><li><a href="Conversation.html#event:member:joined">member:joined</a></li><li><a href="Conversation.html#event:member:left">member:left</a></li><li><a href="Conversation.html#event:text:seen">text:seen</a></li><li><a href="Conversation.html#event:text:typing:off">text:typing:off</a></li><li><a href="Conversation.html#event:text:typing:on">text:typing:on</a></li><li><a href="ConversationClient.html#event:connecting">connecting</a></li><li><a href="ConversationClient.html#event:disconnect">disconnect</a></li><li><a href="ConversationClient.html#event:error">error</a></li><li><a href="ConversationClient.html#event:ready">ready</a></li><li><a href="ConversationClient.html#event:reconnect">reconnect</a></li><li><a href="ConversationClient.html#event:reconnecting">reconnecting</a></li></ul><h3>Global</h3><ul><li><a href="global.html#ConversationClientErrorTypes">ConversationClientErrorTypes</a></li><li><a href="global.html#me">me</a></li><li><a href="global.html#NexmoApiError">NexmoApiError</a></li><li><a href="global.html#NexmoClientError">NexmoClientError</a></li><li><a href="global.html#NexmoClientErrorTypes">NexmoClientErrorTypes</a></li></ul>
</nav>

<br class="clear">

<footer>
    Documentation generated by <a href="https://github.com/jsdoc3/jsdoc">JSDoc 3.5.5</a> on Mon Dec 04 2017 18:00:41 GMT+0000 (GMT)
</footer>

<script> prettyPrint(); </script>
<script src="scripts/linenumber.js"> </script>
</body>
</html>
