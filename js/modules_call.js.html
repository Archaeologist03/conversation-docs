<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>JSDoc: Source: modules/call.js</title>

    <script src="scripts/prettify/prettify.js"> </script>
    <script src="scripts/prettify/lang-css.js"> </script>
    <!--[if lt IE 9]>
      <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    <link type="text/css" rel="stylesheet" href="styles/prettify-tomorrow.css">
    <link type="text/css" rel="stylesheet" href="styles/jsdoc-default.css">
</head>

<body>

<div id="main">

    <h1 class="page-title">Source: modules/call.js</h1>

    



    
    <section>
        <article>
            <pre class="prettyprint source linenums"><code>/*
 * Conversation SDK
 *  Call object model
 *
 * Copyright (c) Nexmo Inc. 2018
 */

var WildEmitter = require('wildemitter');
var ConversationClientError = require('../conversationClientError');
var logger = require('loglevel');

// var NexmoApiError = ConversationClientError.NexmoApiError;
var NexmoClientError = ConversationClientError.NexmoClientError;

/**
 * Conversation Call object.
 * @class Call
 * @property {Conversation} conversation - The conversation of the call.
 * @property {Member} from - The caller.
 * @property {Member[]} to - The callees. When we trigger the call we get the invites that will resolve to the Members that have been invited
 */
var Call = function(application, conversation) {
	this.application = application;
	this.log = logger.getLogger("Call");
	// there are cases we want to create a Call object and then trigger the flow (create conversation)
	// but for incoming calls we have the conversation we got invited to before we create this object
	if (conversation) {
		this.conversation = conversation;
		this.from = conversation.members; // TODO filter here and get the first joined member (caller) 
		this.to = conversation.members; // TODO remove the caller and keep the other members
	}

	WildEmitter.call(this);
};

Call.prototype = new WildEmitter();
//reset the original Type
Call.prototype.constructor = Call;

/**
 * Trigger the call flow for the input users.
 * Create a conversation with prefix name "CALL_" 
 * and invite all the users.
 * If at least one user is successfully invited, enable the audio.
 * 
 * @param {string[]} usernames the usernames of the users to call
 * @returns {Promise[]} an array of the invite promises for the provided usernames
 */
Call.prototype.createCall = function(usernames) {
	if (!usernames || !Array.isArray(usernames) || usernames.length === 0) {
		return Promise.reject(new NexmoClientError("error:application:call:params"));
	}
	var self = this;

	return self.application.newConversationAndJoin({ display_name: "CALL_" + self.application.me.name + "_" + usernames.join("_").replace(" ", "") })
		.then(function(conversation) {
			self.from = conversation.me;
			self.conversation = conversation;
			self.successful_invited_members = [];
			var invites = usernames.map(
				//check all invites, if at least one is resolved enable audio
				function(username) {

					// we need to catch rejections to allow all the chain to go through (all invites)
					// we then catch-reject a promise so that the errors are passing through the end of the chain
					return conversation.inviteWithAudio({ user_name: username })
						.then(function(member) {
							self.successful_invited_members.push(member);
							self.log.debug(member);
							return Promise.resolve(member);
						})
						.catch(function(error) {
							self.log.warn(error);
							// resolve the error to allow the promise.all to collect
							// and return all the promises
							return Promise.resolve(error);
						})
				});
			//helper function to process in Promise.all() the failed invites too
			var process_invites = function() {
				if (self.successful_invited_members.length > 0) {
					return conversation.media.enable({ audio: { muted: false, earmuffed: false } })
						.then(function() {
							return Promise.resolve(invites);
						})
				} else {
					return Promise.reject(invites);
				}
			};
			// we need to continue the invites even if one fails,
			// in process_invites we do the check if at least one was successful 
			return Promise.all(invites)
				.then(function() {
					return process_invites();
				});
		});

}

/**
 * Hangs up the call
 * Leave from the conversation
 * Disable the audio
 * When there is only one member left, after this leaves, kick the other one too.
 * The call ends when last pair of participants break
 * 
 * @returns {Promise} resolves a promise
 */
Call.prototype.hangUp = function() {
	var self = this;
	// if there is only one other member joined, kick it and then leave
	if (Object.keys(self.conversation.members).length > 1) {
		var other_joined_members = []; //excluding our member

		for (var member_id in self.conversation.members) {
			if (!self.conversation.members[member_id]) continue;
			var member = self.conversation.members[member_id];
			if (member.state === "JOINED" &amp;&amp; member.user.id !== self.application.me.id) {
				other_joined_members.push(member);
			}
		}
		if (other_joined_members.length === 1) {
			// if we kick someone we need to make sure to leave after that- rejects or fulfils
			// we need to force the sequence of events
			return other_joined_members[0].kick().then(self.conversation.leave).catch(self.conversation.leave);
		}
	}
	return self.conversation.leave();
}

/**
 * Rejects an incoming call
 * Leave from the conversation that you are invited
 * 
 * @returns {Promise} resolves a promise
 */
Call.prototype.reject = function() {
	var self = this;
	if (self.conversation) {
		return self.conversation.leave();
	} else {
		return Promise.reject(new NexmoClientError("error:call:reject"));
	}
}

/**
 * Answers an incoming call
 * Join the conversation that you are invited
 * 
 * @returns {Promise} resolves a promise
 */
Call.prototype.answer = function() {
	var self = this;
	if (self.conversation) {
		return self.conversation.join().then(function() {
			return self.conversation.media.enable();
		});
	} else {
		return Promise.reject(new NexmoClientError("error:call:answer"));
	}
}

module.exports = {
	Call: Call
};
</code></pre>
        </article>
    </section>




</div>

<nav>
    <h2><a href="index.html">Home</a></h2><h3>Classes</h3><ul><li><a href="Application.html">Application</a></li><li><a href="Call.html">Call</a></li><li><a href="Conversation.html">Conversation</a></li><li><a href="ConversationClient.html">ConversationClient</a></li><li><a href="Event.html">Event</a></li><li><a href="ImageEvent.html">ImageEvent</a></li><li><a href="Media.html">Media</a></li><li><a href="Member.html">Member</a></li><li><a href="TextEvent.html">TextEvent</a></li></ul><h3>Events</h3><ul><li><a href="Application.html#event:member:call">member:call</a></li><li><a href="Application.html#event:member:invited">member:invited</a></li><li><a href="Application.html#event:member:joined">member:joined</a></li><li><a href="Application.html#event:sync:progress">sync:progress</a></li><li><a href="Conversation.html#event:event:delete">delete</a></li><li><a href="Conversation.html#event:image">image</a></li><li><a href="Conversation.html#event:text">text</a></li><li><a href="Conversation.html#event:image:seen">image:seen</a></li><li><a href="Conversation.html#event:member:invited">member:invited</a></li><li><a href="Conversation.html#event:member:joined">member:joined</a></li><li><a href="Conversation.html#event:member:left">member:left</a></li><li><a href="Conversation.html#event:member:media">member:media</a></li><li><a href="Conversation.html#event:text:seen">text:seen</a></li><li><a href="Conversation.html#event:text:typing:off">text:typing:off</a></li><li><a href="Conversation.html#event:text:typing:on">text:typing:on</a></li><li><a href="ConversationClient.html#event:connecting">connecting</a></li><li><a href="ConversationClient.html#event:disconnect">disconnect</a></li><li><a href="ConversationClient.html#event:error">error</a></li><li><a href="ConversationClient.html#event:ready">ready</a></li><li><a href="ConversationClient.html#event:reconnect">reconnect</a></li><li><a href="ConversationClient.html#event:reconnecting">reconnecting</a></li></ul><h3>Global</h3><ul><li><a href="global.html#ConversationClientErrorTypes">ConversationClientErrorTypes</a></li><li><a href="global.html#me">me</a></li><li><a href="global.html#NexmoApiError">NexmoApiError</a></li><li><a href="global.html#NexmoClientError">NexmoClientError</a></li><li><a href="global.html#NexmoClientErrorTypes">NexmoClientErrorTypes</a></li></ul>
</nav>

<br class="clear">

<footer>
    Documentation generated by <a href="https://github.com/jsdoc3/jsdoc">JSDoc 3.5.5</a> on Tue Feb 20 2018 17:01:07 GMT+0000 (GMT)
</footer>

<script> prettyPrint(); </script>
<script src="scripts/linenumber.js"> </script>
</body>
</html>
